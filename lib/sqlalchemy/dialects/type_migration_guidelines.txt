Rules for Migrating TypeEngine classes to 0.6
---------------------------------------------

1. the TypeEngine classes are used for:

    a. Specifying behavior which needs to occur for bind parameters
    or result row columns.
    
    b. Specifying types that are entirely specific to the database
    in use and have no analogue in the sqlalchemy.types package.
    
    c. Specifying types where there is an analogue in sqlalchemy.types,
    but the database in use takes vendor-specific flags for those
    types.

    d. If a TypeEngine class doesn't provide any of this, it should be
    *removed* from the dialect.
    
2. the TypeEngine classes are *no longer* used for:

    a. generating DDL
    
3. the "ischema_names" and "colspecs" dictionaries are now required members on
the Dialect class.

4. The names of types within dialects are now important.   If a dialect-specific type
is a subclass of an existing generic type and is only provided for bind/result behavior, 
the current mixed case naming can remain, i.e. PGNumeric for Numeric - in this case, 
end users would never need to use PGNumeric directly.   However, if a dialect-specific 
type is specifying a type *or* arguments that are not present generically, it should
match the real name of the type on that backend, in uppercase.  E.g. postgres.INET,
mysql.ENUM, postgres.ARRAY.  

Ideally one should be able to specify a schema using names imported completely from a 
dialect, all matching the real name on that backend:

   from sqlalchemy.dialects.postgres import base as pg
   
   t = Table('mytable', metadata,
              Column('id', pg.INTEGER, primary_key=True),
              Column('name', pg.VARCHAR(300)),
              Column('inetaddr', pg.INET)
   )

where above, the INTEGER and VARCHAR types are ultimately from sqlalchemy.types, 
but the PG dialect makes them available in its own namespace.

5. "colspecs" now is a dictionary of generic or uppercased types from sqlalchemy.types
linked to types specified in the dialect.   Again, if a type in the dialect does not
specify any special behavior for bind_processor() or result_processor() and does not
indicate a special type only available in this database, it must be *removed* from the 
module and from this dictionary.

6. "ischema_names" indicates string descriptions of types as returned from the database
linked to TypeEngine classes.   

    a. The string name should be matched to the most specific type possible within
    sqlalchemy.types, unless there is no matching type within sqlalchemy.types in which
    case it points to a dialect type.   *It doesn't matter* if the dialect has it's 
    own subclass of that type with special bind/result behavior - reflect to the generic type
    as much as possible, since the correct bind/result behavior is always invoked when needed
    regardless of the type being generic or dialect-specific.
    
    b. If the dialect contains a matching dialect-specific type that takes extra arguments 
    which the generic one does not, then point to the dialect-specific type.  E.g.
    mssql.VARCHAR takes a "collation" parameter which should be preserved.
    
    c. For an exact or almost exact match, point to the uppercase type.  i.e. "float" 
    should point to "FLOAT", "varchar" should point to "VARCHAR"
    
    d. for a non-match, point to the lowercase type.  i.e. "long" should point to "Text",
    "special varchar with sprinkles" points to "String".
    
5. DDL, or what was formerly issued by "get_col_spec()", is now handled exclusively by
a subclass of compiler.GenericTypeCompiler.

    a. your TypeCompiler class will receive generic and uppercase types from 
    sqlalchemy.types.  Do not assume the presence of dialect-specific attributes on
    these types. 
    
    b. the visit_UPPERCASE methods on GenericTypeCompiler should *not* be overridden with
    methods that produce a different DDL name.   Uppercase types don't do any kind of 
    "guessing" - if the user says he wants TIMESTAMP, that's the DDL which should render, 
    regardless of whether the DB accepts it.
    
    c. the visit_UPPERCASE methods *should* be overridden with methods that add additional
    arguments and flags to those types.  
    
    d. the visit_lowercase methods are overridden to provide an interpretation of a generic 
    type.  E.g.  visit_binary() might be overridden to say "return self.visit_BIT(type_)".
    
    e. when overriding a visit_lowercase method to return a different type, it should not
    represent the DDL string within the body of the method; it should call the appropriate
    visit_UPPERCASE name.
